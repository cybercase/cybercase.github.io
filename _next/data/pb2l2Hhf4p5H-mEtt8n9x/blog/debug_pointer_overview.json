{"pageProps":{"post":{"slug":"debug_pointer_overview","title":"Debug Pointer: a quick overview","description":"C++ Smart Pointer for Debugging - Design Decisions","date":"2012-09-01T00:00:01.000Z","content":"<h1>Debug Pointer: a quick overview</h1>\n<p>Let’s focus on some keypoints of my debug_ptr:</p>\n<ul>\n<li>\n<p>What a debug_ptr is used for?\nA debug_ptr can be used like a standard pointer type to hold the address of a dynamically allocated object:\n<code>typedef_pointer(int*, int_p); int_p p = new int(0);</code></p>\n</li>\n<li>\n<p>How could it be useful?\nIf you forget to delete a dynamically allocated object before loosing its last reference, you are probably creating a memory leak. A debug_ptr warns you about this fact using a warning policy.</p>\n<p>struct ThrowPolicy {\nThrowPolicy() {\nthrow std::runtime_error(“lost reference to undeleted object”);\n}\n};\nstruct PrintPolicy {\nPrintPolicy() {\nstd::cerr &#x3C;&#x3C; “WARNING: lost reference ”\n“to undeleted object” &#x3C;&#x3C; std::endl;\n}\n};</p>\n</li>\n<li>\n<p>How much does it cost? (in performance terms)\nThe features of debug_ptr are mostly useful in “debug mode”. In a production release, you may not want use the features of a debug_ptr class (although you can), because of the performance losses due to the reference counting.</p>\n</li>\n<li>\n<p>How did I address this issue?\nYou can compile your software by defining ENABLE_DEBUG_TYPES to get the debug_ptr feature turned on. Otherwise all the debug_ptr features are turned off by a macro that will substitute any occurrence of debug_ptr<T> with a T*. This will avoid any overhead at compile and run time.</p>\n<p>#ifndef ENABLE_DEBUG_TYPES\n#define typedef_pointer(Type, Alias, …) typedef Type Alias\n#define typedef_array(Type, Alias, …) typedef Type Alias\n#else // ENABLE_DEBUG_TYPES\n…\n#endif</p>\n</li>\n<li>\n<p>How debug_ptr syntax differs by the one of a standard pointer type?\ndebug_ptr it’s intended to be used just like any other smart_ptr, and in most of the cases you should not notice any difference in creating, copying, dereferencing, assigning, and deleting…</p>\n<p>typedef_pointer(int*, int_p);\nint_p p = new int(0);\nint_p p_other = new int(0);\n*p = 63;\nint_p p_other = p;\ndelete p_other;</p>\n</li>\n<li>\n<p>How did you get the same delete syntax of a standard pointer type?\nBy defining a default cast operator to a pointer-to-deleter-class. The cast operator will be implicitly called and a new deleter object returns to operator delete. So, delete operator, deletes the deleter-class.</p>\n<p>operator deleter*() const {\nreturn deleter::new_deleter(pd_);\n}</p>\n</li>\n</ul>\n<p>And that’s all folks!</p>\n<p>If you have any question, just leave a comment.\nIf you like this project, or have any other ideas about what could be the next step of the debug_ptr, fork the project on github and have fun :)</p>\n<pre><code class=\"hljs language-bash\">git <span class=\"hljs-built_in\">clone</span> git://github.com/cybercase/debug_ptr.git <span class=\"hljs-comment\"># clone the repo</span>\n<span class=\"hljs-built_in\">cd</span> debug_ptr\ng++ -Wall -o <span class=\"hljs-built_in\">test</span> debug_ptr_test.cc -DENABLE_DEBUG_TYPES\n./test\n</code></pre>\n<p><em>—01/09/2012</em></p>"}},"__N_SSG":true}