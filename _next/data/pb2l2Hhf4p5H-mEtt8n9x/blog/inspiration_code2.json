{"pageProps":{"post":{"slug":"inspiration_code2","title":"Inspiration Code - part 2","description":"Code I wrote after reading a book - second part","date":"2011-12-20T00:00:01.000Z","content":"<h1>Inspiration Code</h1>\n<h2>Part 2</h2>\n<p>Since the <code>pthread_create</code> function signature allows running of <code>void*(*)(void*)</code> function type only, I was quite sure on packaging into a struct both the callable object and its args, and pass them to some function matching that signature. Here is the “some function” I named <code>_help_fn</code>:</p>\n<pre><code class=\"hljs language-arduino\"><span class=\"hljs-keyword\">template</span> &#x3C;S> <span class=\"hljs-type\">void</span>* _help_fn(<span class=\"hljs-type\">void</span>* v)\n{\n    <span class=\"hljs-comment\">// This function signature match the one needed by</span>\n    <span class=\"hljs-comment\">// pthread_create func.</span>\n    S* st = (S*)v;\n    st-><span class=\"hljs-built_in\">exec</span>();\n    <span class=\"hljs-keyword\">delete</span> st;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;\n};\n</code></pre>\n<p>The <code>S</code> template parameter is meant to be the type of a package struct. The exec() method from this struct should call any callable type, together with its arguments and, obviously, write somewhere the return value of the call.\nThis is how I wrote the package struct, named <code>_help_st</code>.</p>\n<pre><code class=\"hljs language-scss\">template &#x3C;typename T, typename <span class=\"hljs-selector-tag\">I</span>> struct _help_st\n{\n    <span class=\"hljs-built_in\">_help_st</span>(_thread&#x3C;T>* t, I f) : functor(f)\n    {\n        thd = t;\n        thd-><span class=\"hljs-built_in\">inc</span>();\n    }\n\n    ~<span class=\"hljs-built_in\">_help_st</span>()\n    {\n        thd-><span class=\"hljs-built_in\">dec</span>();\n    }\n\n    <span class=\"hljs-selector-tag\">I</span> functor;\n    _thread&#x3C;T>* thd;\n\n    void <span class=\"hljs-built_in\">exec</span>()\n    {\n        thd->result = <span class=\"hljs-built_in\">functor</span>();\n    }\n};\n</code></pre>\n<p>For now, don’t pay too much attention to the <code>_thread</code> member variable… You just need to know that this member variable holds the result of thread’s computations.\nI assigned <code>exec()</code> member function just the task of storing the returned value by a some callable object. The return value type is told by template parameter <code>T</code>. Then, the dirty job of calling the function with all of its args is left to a functor object of type <code>I</code>.</p>\n<p>I didn’t find any other way than writing as many functors as needed to match all of the previously told callable types.\nThis is the functor for instance method pointers receiving one arg:</p>\n<pre><code class=\"hljs language-scss\">template &#x3C;typename T, typename C, typename I0> struct _class_functor1\n{\n    <span class=\"hljs-built_in\">_class_functor1</span>(C* c, T(C::*m)(I0), I0 a0) : m(m), c(c), a0(a0) {}\n    T <span class=\"hljs-built_in\">operator</span>()() { return (c->*m)(a0); }\n    <span class=\"hljs-built_in\">T</span>(C::*m)(I0);\n    C* c;\n    I0 a0;\n}\n</code></pre>\n<p>And this is the functor for all the other kinds of callable objects receiving one arg:</p>\n<pre><code class=\"hljs language-scss\">template &#x3C;typename T, typename O, typename I0> struct _functor1\n{\n    <span class=\"hljs-built_in\">_functor1</span>(O obj, I0 a0) : o(obj), a0(a0) {}\n    T <span class=\"hljs-built_in\">operator</span>()() { return <span class=\"hljs-built_in\">o</span>(a0); }\n    O o;\n    I0 a0;\n}\n</code></pre>\n<p>I needed a special functor object like <code>_class_functor1</code> for handling instance methods. This is because C++ don’t provide a way to store the callable result of <code>(c->*m)</code>.</p>\n<p><em>— 20/12/2011</em></p>"}},"__N_SSG":true}