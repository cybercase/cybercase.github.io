{"pageProps":{"post":{"slug":"sorting_priorities","title":"Sorting Priorities","description":"Template Sorting in C++","date":"2012-01-15T00:00:01.000Z","content":"<h1>Sorting Priorities</h1>\n<p>Let’s say you have your 3d colored point type:</p>\n<pre><code class=\"hljs language-arduino\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">MyPoint</span>\n{\n    <span class=\"hljs-comment\">// A 3d colored point</span>\n    <span class=\"hljs-built_in\">MyPoint</span>(<span class=\"hljs-type\">int</span> c, <span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y, <span class=\"hljs-type\">int</span> d) :\n             <span class=\"hljs-built_in\">color</span>(c), <span class=\"hljs-built_in\">x</span>(x), <span class=\"hljs-built_in\">y</span>(y), <span class=\"hljs-built_in\">d</span>(d) {}\n    <span class=\"hljs-type\">int</span> color;\n    <span class=\"hljs-type\">int</span> x;\n    <span class=\"hljs-type\">int</span> y;\n    <span class=\"hljs-type\">int</span> d;\n};\n</code></pre>\n<p>You define a vector of <code>MyPoint</code> objects carefully ordered by color, depth, height and width.</p>\n<pre><code class=\"hljs language-ini\">int <span class=\"hljs-attr\">width</span> = <span class=\"hljs-number\">100</span><span class=\"hljs-comment\">;</span>\nint <span class=\"hljs-attr\">height</span> = <span class=\"hljs-number\">100</span><span class=\"hljs-comment\">;</span>\nint <span class=\"hljs-attr\">depth</span> = <span class=\"hljs-number\">5</span><span class=\"hljs-comment\">;</span>\nint <span class=\"hljs-attr\">colors</span> = <span class=\"hljs-number\">2</span><span class=\"hljs-comment\">;</span>\n\nint <span class=\"hljs-attr\">len</span> = width * height * colors * depth<span class=\"hljs-comment\">;</span>\nstd::vector&#x3C;MyPoint> pts<span class=\"hljs-comment\">;</span>\npts.reserve(len)<span class=\"hljs-comment\">;</span>\n\nfor (int <span class=\"hljs-attr\">c</span>=<span class=\"hljs-number\">0</span><span class=\"hljs-comment\">; c&#x3C;colors; ++c)</span>\n    for (int <span class=\"hljs-attr\">d</span>=<span class=\"hljs-number\">0</span><span class=\"hljs-comment\">; d&#x3C;depth; ++d)</span>\n        for (int <span class=\"hljs-attr\">y</span>=<span class=\"hljs-number\">0</span><span class=\"hljs-comment\">; y&#x3C;height; ++y)</span>\n            for (int <span class=\"hljs-attr\">x</span>=<span class=\"hljs-number\">0</span><span class=\"hljs-comment\">; x&#x3C;width; ++x)</span>\n                pts.push_back(MyPoint(c, x, y, d))<span class=\"hljs-comment\">;</span>\n</code></pre>\n<p>Then one of your funny colleagues put a</p>\n<pre><code class=\"hljs language-css\">std::<span class=\"hljs-built_in\">random_shuffle</span>(pts.<span class=\"hljs-built_in\">begin</span>(), pts.<span class=\"hljs-built_in\">end</span>());\n</code></pre>\n<p>just the line before you are scanning the ordered array of <code>MyPoint</code>… If it’s not a colleague, could be that you need to apply a transformation matrix to all of your points, or whatever else that will break the color, depth, height and width ordering of your set.</p>\n<p>To order back your vector by the same priorities, you can use the STL sort algorithm with some custom comparison function.\nThe the first function I wrote was this:</p>\n<pre><code class=\"hljs language-kotlin\">bool mypoint_all_sort_fn(<span class=\"hljs-keyword\">const</span> MyPoint&#x26; p0, <span class=\"hljs-keyword\">const</span> MyPoint&#x26; p1)\n{\n    <span class=\"hljs-keyword\">if</span> (p0.color &#x3C; p1.color)\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (p0.color == p1.color)\n        <span class=\"hljs-keyword\">if</span> (p0.d &#x3C; p1.d)\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (p0.d == p1.d)\n            <span class=\"hljs-keyword\">if</span> (p0.y &#x3C; p1.y)\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (p0.y == p1.y)\n                <span class=\"hljs-keyword\">if</span> (p0.x &#x3C; p1.x)\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n}\n</code></pre>\n<p>and then <code>std::sort(pts.begin(), pts.end(), mypoint_all_sort_fn);</code></p>\n<p>I found this solution the ugliest among the others. It’s not scalable, has too many indentations and strong code dependancy… And also if <code>mypoint_all_sort_fn</code> was defined as operator inside <code>MyStruct</code> declaration I wouldn’t like to have such a function inside my software.</p>\n<p>The second solution I came to was using several <code>stable_sort</code></p>\n<pre><code class=\"hljs language-arduino\"><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">mypoint_x_sort_fn</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> MyPoint&#x26; p0, <span class=\"hljs-type\">const</span> MyPoint&#x26; p1)</span>\n</span>{\n    <span class=\"hljs-keyword\">return</span> p0.x &#x3C; p1.x;\n}\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">mypoint_y_sort_fn</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> MyPoint&#x26; p0, <span class=\"hljs-type\">const</span> MyPoint&#x26; p1)</span>\n</span>{\n    <span class=\"hljs-keyword\">return</span> p0.y &#x3C; p1.y;\n}\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">mypoint_d_sort_fn</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> MyPoint&#x26; p0, <span class=\"hljs-type\">const</span> MyPoint&#x26; p1)</span>\n</span>{\n    <span class=\"hljs-keyword\">return</span> p0.d &#x3C; p1.d;\n}\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">mypoint_c_sort_fn</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> MyPoint&#x26; p0, <span class=\"hljs-type\">const</span> MyPoint&#x26; p1)</span>\n</span>{\n    <span class=\"hljs-keyword\">return</span> p0.color &#x3C; p1.color;\n}\n</code></pre>\n<p>and then</p>\n<pre><code class=\"hljs language-css\">std::<span class=\"hljs-built_in\">stable_sort</span>(pts.<span class=\"hljs-built_in\">begin</span>(), pts.<span class=\"hljs-built_in\">end</span>(), mypoint_x_sort_fn);\nstd::<span class=\"hljs-built_in\">stable_sort</span>(pts.<span class=\"hljs-built_in\">begin</span>(), pts.<span class=\"hljs-built_in\">end</span>(), mypoint_y_sort_fn);\nstd::<span class=\"hljs-built_in\">stable_sort</span>(pts.<span class=\"hljs-built_in\">begin</span>(), pts.<span class=\"hljs-built_in\">end</span>(), mypoint_d_sort_fn);\nstd::<span class=\"hljs-built_in\">stable_sort</span>(pts.<span class=\"hljs-built_in\">begin</span>(), pts.<span class=\"hljs-built_in\">end</span>(), mypoint_c_sort_fn);\n</code></pre>\n<p>I found this solution not too bad by the code style point of view, but it’s not the same about performances. More are the values you want to sort by, more are the stable_sort steps you have to do.</p>\n<p>The last solution, which I found the most fascinating one, was suggested to me by two of my collegues, and it took me a just a small bunch of time to write the code down.</p>\n<pre><code class=\"hljs language-arduino\"><span class=\"hljs-keyword\">template</span> &#x3C;<span class=\"hljs-keyword\">typename</span> T> <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">element</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> T&#x26;, <span class=\"hljs-type\">int</span> i)</span></span>;\n\n<span class=\"hljs-keyword\">template</span> &#x3C;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-type\">int</span> I> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Orderer</span>\n{\n    <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">compare</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> T&#x26; t0, <span class=\"hljs-type\">const</span> T&#x26; t1)</span>\n    </span>{\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">element</span>(t0, I) == <span class=\"hljs-built_in\">element</span>(t1, I))\n            <span class=\"hljs-keyword\">return</span> Orderer&#x3C;T, I<span class=\"hljs-number\">-1</span>>::<span class=\"hljs-built_in\">compare</span>(t0, t1);\n        <span class=\"hljs-keyword\">else</span>\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">element</span>(t0, I) &#x3C; <span class=\"hljs-built_in\">element</span>(t1, I);\n    }\n};\n<span class=\"hljs-keyword\">template</span> &#x3C;<span class=\"hljs-keyword\">typename</span> T> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Orderer</span>&#x3C;T, <span class=\"hljs-number\">-1</span>>\n{\n    <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">compare</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> T&#x26; t0, <span class=\"hljs-type\">const</span> T&#x26; t1)</span>\n    </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n    }\n};\n</code></pre>\n<p>Using templates it’s possible to make the compiler generate the ugly if-else code. Then the task of providing the right element for the sorting is demanded to an element(int) function. Also, it’s possible substitute the element(int) function with an element(int) member function (or maybe an operator) in <code>MyPoint</code> definition. This is how it work:</p>\n<pre><code class=\"hljs language-csharp\">template &#x3C;> <span class=\"hljs-function\"><span class=\"hljs-built_in\">int</span> <span class=\"hljs-title\">element</span>&#x3C;<span class=\"hljs-title\">MyPoint</span>>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">const</span> MyPoint&#x26; p, <span class=\"hljs-built_in\">int</span> i</span>)</span>\n{\n    <span class=\"hljs-comment\">// Watch out!</span>\n    <span class=\"hljs-comment\">// The higher is the i-value, the most significant is the member</span>\n    <span class=\"hljs-keyword\">switch</span>(i)\n    {\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">3</span>:\n            <span class=\"hljs-keyword\">return</span> p.color;\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">2</span>:\n            <span class=\"hljs-keyword\">return</span> p.d;\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">1</span>:\n            <span class=\"hljs-keyword\">return</span> p.y;\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">0</span>:\n            <span class=\"hljs-keyword\">return</span> p.x;\n        <span class=\"hljs-literal\">default</span>:\n            <span class=\"hljs-keyword\">throw</span> std::invalid_argument(<span class=\"hljs-string\">\"Undefined element\"</span>);\n    }\n}\n<span class=\"hljs-function\"><span class=\"hljs-built_in\">bool</span> <span class=\"hljs-title\">mypoint_sort</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">const</span> MyPoint&#x26; t0, <span class=\"hljs-keyword\">const</span> MyPoint&#x26; t1</span>)</span>\n{\n    <span class=\"hljs-keyword\">return</span> Orderer&#x3C;MyPoint, <span class=\"hljs-number\">3</span>>::compare(t0, t1);\n}\n</code></pre>\n<p>and then <code>std::sort(pts.begin(), pts.end(), mypoint_sort);</code></p>\n<p>That’s it! A more readable switch-case statement provides the priority of sorting… and the <code>mypoint_sort</code> function call the template right specialization of Orderer Struct static compare function.</p>\n<p>Here how you can find, compile and run the code for this example:</p>\n<pre><code class=\"hljs language-bash\">git <span class=\"hljs-built_in\">clone</span> git://github.com/cybercase/funproject.git\n<span class=\"hljs-built_in\">cd</span> funproject/other\ng++ order.cpp -o order -Wall\n</code></pre>\n<p>One interesting thing I discovered while writing the code of this example, is that you can’t use template function specialization. I found a discussion about this topic at <a href=\"http://www.gotw.ca/publications/mill17.htm\">http://www.gotw.ca/publications/mill17.htm</a>. The Peter Dimov and Dave Abrahams example shows why template specialization can’t be done with functions.</p>\n<p><em>— 15/01/2012</em></p>"}},"__N_SSG":true}