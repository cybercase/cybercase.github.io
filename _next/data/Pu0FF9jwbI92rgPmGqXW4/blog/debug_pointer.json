{"pageProps":{"post":{"slug":"debug_pointer","title":"Debug Pointer","description":"C++ Smart Pointer for Debugging","date":"2012-08-22T00:00:01.000Z","content":"<h1>Debug Pointer</h1>\n<p>As I mentioned in the last post, lately I’m working on a C++/Boost software (aka speeding up and refactoring an unmaintainable software). This software is just a kind of parser. It parses several binary files and, for each one, produces a xml file. Also it needs to merge and summarise some of the fields contained in each one of these files to produce a <em>Final Report</em> xml file.</p>\n<p>There may be several way to write a software for a task like this, and the customer choosed to use threads. A big mistake, because (IMHO) Who wrote the software did not have any idea of how use threads efficently, and he ended up using a lot of locks and semaphores everywhere… but this is another story.</p>\n<p>The most impressive thing that I saw in this software was the inconsiderate abuse of Boost shared pointers. These were used almost everywhere in the software in every nonsense way they could be used… passing them around by copy or just like the following:</p>\n<pre><code class=\"hljs language-css\">for (int <span class=\"hljs-selector-tag\">i</span>=<span class=\"hljs-number\">0</span>; <span class=\"hljs-selector-tag\">i</span>&#x3C;SOMEINT; ++<span class=\"hljs-selector-tag\">i</span>) {\n    // Why not: SOMECLASS sp; ???\n    boost::shared_ptr&#x3C;SOMECLASS> <span class=\"hljs-built_in\">sp</span>(new SOMECLASS);\n    sp->SomeMethod();\n}\n</code></pre>\n<p>Just by fixing these kind of misuses, I’ve got a speedup of over 2x.</p>\n<p>Shared pointers can be really useful but they:</p>\n<ul>\n<li>should be used with care because they can become really expensive</li>\n<li>should not be used just to avoid thinking about memory management in your software</li>\n</ul>\n<p>And the last point is the one that I felt was the case of this software. For this reason, and for helping myself to refactor and remove shared pointers from this software, I wrote my own smart pointer: <strong>debug_ptr</strong>.</p>\n<p><strong>debug_ptr</strong> is a smart pointer that should help the developer to manage the memory correctly (a delete for every new). A debug_ptr just warn the developer when he forgets to delete an dynamically allocated object, so that he can insert the correct delete (or <code>delete[]</code>) statement.\nAlso, debug_ptr is designed in a way such that, once you have tested your software and no memory leaks warning are raised anymore, it can be automatically substituted with a native pointer type, so that no overhead is added both at run and compile time.</p>\n<p>For now you can check the debug_ptr source code and have a look at the few test cases that show how it can\nbe used. It’s located in my debug_ptr repository on github:</p>\n<pre><code class=\"hljs language-bash\">git <span class=\"hljs-built_in\">clone</span> git://github.com/cybercase/debug_ptr.git <span class=\"hljs-comment\"># clone the repo</span>\n<span class=\"hljs-built_in\">cd</span> debug_ptr\ng++ -Wall -o <span class=\"hljs-built_in\">test</span> debug_ptr_test.cc -DENABLE_DEBUG_TYPES\n./test\n</code></pre>\n<p>In the next post, I’ll try to focus on some interesting parts of this very simple smart pointer.</p>\n<p><em>—22/08/2012</em></p>"}},"__N_SSG":true}